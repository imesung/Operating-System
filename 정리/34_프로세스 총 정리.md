## 프로세스의 전체 로직을 살펴보자.

1. 사용자 모드에서 프로그램 실행

![image](https://user-images.githubusercontent.com/40616436/81704696-17eccc00-94a9-11ea-95bf-d87b1fcf8286.png)

2. 컴파일러에 의한 실행파일은 운영체제 올라가는데, 아래와 같은 **프로세스 구조** 형식으로 올라간다.

<img src="https://user-images.githubusercontent.com/40616436/81704969-6d28dd80-94a9-11ea-85d0-f7224678cb5d.png" alt="image" style="zoom:50%;" />

- 전역변수만 있으므로 TEXT Segment에만 코드가 올라갈 것이다.

3. 이제 우리의 프로그램을 실행을 하기 위해선 ready 상태에 있게 될 것이다.

   <img src="https://user-images.githubusercontent.com/40616436/81705824-69e22180-94aa-11ea-9d9f-54e2a58aebde.png" alt="image" style="zoom:50%;" />

   - 스케줄러 방식에 따라 ready에서 running 상태로 변경이 될텐데, **하나의 예로 현재 운영체제는 선점형 스케줄러 방식으로 프로세스를 변경해주고 있다고 생각해보자.**
     - 해당 스케줄러 방식은 0.01초 마다 인터럽트가 발생하고, 인터럽트에 count 값이 5가 되면 스케줄러에 의해서 컨텍스트 스위칭이 발생한다고 하자.
     - **그럼 위의 스케줄러 방식에 의해 우리가 구성한 프로그램은 0.05초 뒤에 running 상태로 변경하게 되어 실행이 되는 것이다.** 

4. 이제 해당 프로그램에서 open()이라는 시스템 콜을 호출한다.

   - open() 내부에 짜여진 어셈블리 코드를 보면,

     ~~~
     mov eax, 1	//시스템 콜 번호
     mov ebx, 0	//인자
     int 0x80		//int : CPU가 제공하는 OPCODE(CPU 명령어), 0x80 : 인터럽트 번호
     ~~~

   - open()에 의해서 int라는 명령을 하게 되는데 해당 명령을 살펴보면, (**인터럽트 방식**)

     1. CPU는 사용자 모드를 커널 모드로 변경.
     2. IDT(Interrupt Descriptor Table)에서 0x80(**실행 커널함수 주소**)에 해당하는 주소(함수)를 찾아서 실행
     3. system_call() 함수에서 eax(**시스템 콜 처리 커널 함수 주소**)로 부터 시스템 콜 번호를 찾아서, 해당 번호에 맞는 시스템 콜 함수로 이동
     4. 해당 시스템 콜 함수 실행 후 다시 커널 모드에서 사용자 모드로 변경하고, 다시 해당 프로세스 다음 코드를 진행

   - 그리고 이제 open()함수를 처리하는 sys_open() 커널 함수를 호출하게 된다.

5. Sys_open()을 실행하게 되면, 저장매체를 접근하는 비용이 매우 커 waiting으로 상태가 변경하게 된다.

   <img src="https://user-images.githubusercontent.com/40616436/81710643-de6a8f80-94ad-11ea-82a8-74a8dcf04c36.png" alt="image" style="zoom:50%;" />

   - 일반 저장(Registers) 보다 저장 매체에 읽어오는(Flash Drive) 비용 차이가 약 1000배 나는 것을 확인할 수 있다.

6. 그 후 저장매체를 통해 데이터를 다 받아오고 DMA가 CPU에게 데이터를 다 받아왔다고 하면, 다시 인터럽트가 발생하게 된다.

   - 해당 인터럽트가 발생하면 4번에 인터럽트 방식을 동일하게 수행하게 된다.

7. 인터럽트가 발생하게 되면 waiting 상태에서 다시 ready 상태로 변환하게 되는 것이다.

8. 그럼 이제 스케줄러 방식에 의해서 다시 running 상태가 되고, 그 후 비로소 다음 코드를 진행하는 것이다.

   <img src="https://user-images.githubusercontent.com/40616436/81704696-17eccc00-94a9-11ea-95bf-d87b1fcf8286.png" alt="image" style="zoom:50%;" />

   - **if(!d == -1) 이 실행되는 것이다.**



**참고**

프로그램을 실행하면서 시스템 콜, 인터럽트 발생이 자주 일어나기 때문에, 사용자 모드에서 커널 모드로 변경하는 것이 매우 많이 일어난다.

IO 관련 처리는 수많은 인터럽트와 관련 시스템 콜, 스케줄러, 하드웨어, 실제 처리 시간도 매우 많이 드는 것을 확인할 수 있다. 그로 인해 프로세스를 구성할 때 IO 처리를 최소화 하는 것이 중요하다.