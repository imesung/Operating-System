## 프로세스간 커뮤니케이션

> InterProcess Communication

- 프로세스들이 서로의 공간을 쉽게 접근할 수 있다면, 프로세스 데이터와 코드가 변경될 수 있으므로 매우 위험한 것이다.
- **즉, 프로세스는 다른 프로세스의 공간(주소)을 접근할 수 없다.**



**IPC(InterProcess Communication)**

- 하지만 프로세스 간의 통신 방법을 제공한다.
  - IPC 기법



**과연 프로세스간 통신이 필요한가?**

- 성능을 높이기 위해 여러 프로세스를 만들어서 동시 실행한다.
- 이 때, **프로세스간 상태 확인 및 데이터 송수신이 필요하다.**
- Ex. fork() 시스템 콜
  - fork() 함수로 프로세스 자신을 복사해서 새로운 프로세스로 만들 수 있다.
    - 부모 프로세스(기존 프로세스), 자식 프로세스(fork()로 생성된 프로세스)
  - 즉, 프로세스를 fork()해서 여러 프로세스를 동시에 실행시킬 수 있는 것이다.
- **최근에는 CPU 안에 코어가 8개되는 경우도 많고, 각 프로세스를 각 코어에 동시 실행이 가능하기 때문이다.(병렬 처리)**
- Ex. 1~10000까지 더하기
  - fork() 함수로 10개의 프로세스를 만들어 각각 1~1000(1초), 1001~2000(1초), ...를 각각 코어에 넣어 동시 실행
  - **각각 더한 값을 모두 합하면 단 1초만에 원하는 결과값을 얻을 수 있다.**
- Ex. 웹 서버의 예
  - 웹 서버는 요청이 오면, HTML 파일을 클라이언트에 제공하는 프로그램이다.
  - 클라이언트와 서버
    - 여러 클라이언트 각각의 요청이 오는 경우, fork() 함수로 새로운 프로세스를 만들고, 각 사용자 요청에 즉시 대응하는 것이다.
    - 만약 해당 작업이 병렬로 처리가 가능하면 더욱 빠를 것이다.
  - **이 때, 각 프로세스의 제어 및 상태 정보 교환을 위해서는 프로세스간의 통신이 필요한 것이다.**



**파일을 사용한 커뮤니케이션**

- 다른 프로세스에 전달할 내용을 파일에 쓰고, 다른 프로세스가 해당 파일을 읽으면 된다.
- 하지만.. 파일을 사용하면 실시간으로 직접 원하는 프로세스에 데이터를 전달하기가 어렵다.
  - why? **해당 프로세스가 파일을 읽어야 하지만 실시간으로 해당 파일을 계속 읽을 수만은 없기 때문이다.**
- 또한, 저장매체에서 데이터를 읽어오는 경로는 매우 복잡하고 오래걸린다.
  - 저장매체에 데이터 읽어오기
    1. 시스템 콜에 의해 파일 오픈
    2. 파일을 읽기 위해 사용자 모드에서 커널 모드로 전환
    3. 스케줄러에 의해 해당 프로세스는 block 상태로 변경
    4. 저장 매체에서 데이터를 읽어 인터럽트 발생
    5. 다 읽을 시 인터럽트를 해당 프로세스에서 받아 running 상태로 변경
    6. 데이터 읽음



**실제 프로세스 : 리눅스 예**

- 프로세스간 공간은 완전히 분리되어 있다.

  <img src="https://user-images.githubusercontent.com/40616436/81202523-b4265700-9001-11ea-93cc-25be2516bdf3.png" alt="image" style="zoom:50%;" />

  