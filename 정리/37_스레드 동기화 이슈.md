**동기화 이슈**

멀티 스레드를 사용하면서 하나의 변수를 여러 스레드에서 변경해주는 경우가 발생하게 되는데, 사용자가 원하는 시점에 변경되는 것이 아니라 다른 시점에 변경되어 예측한 결과값이 안나타날 수 있다. 이런 경우를 동기화 이슈라고 하고, 이런 이슈를 방지하기 위해서는 추가적인 관리가 필요하다. 

Ex. 동기화 이슈

스레드 두개를 이용해서 1~100까지 덧셈을 진행하려고 할 때, 각각 더한 결과값을 result라는 변수에 넣고 해당 변수를 다시 이용해서 덧셈을 진행하고 있다. 하지만 스레드는 순차적으로 덧셈을 진행하는 것이 아니고 현재의 result 결과값만 보고 있어 계산을 진행하던 중 Context Switching이 발생하여 result에 계산한 결과값이 저장되지 않아 덧셈이 누락되는 경우가 발생할 수 있다.

**해결,** 하나의 스레드에서 계산을 진행 후 결과값을 저장할 때 다른 스레드가 침범하지 못하도록 lock을 걸어놓으면 되는 것이다. 즉, 임계영역(계산 및 결과 값 저장하는 CPU를 사용하는 영역)에 다른 스레드가 Context Switching 하지 못하도록 lock을 걸어놓는 것이다.

---

- 동기화 : 작업들 사이에 실행 시기를 맞추는 것이다.
- 여러 스레드가 동일한 자원 접근 시 동기화 이슈가 발생한다.
  - 동일 자원을 여러 스레드가 동시 수정 시에 발생하고, 이로 인해 각 스레드 결과에 영향을 주는 것이다.

**동기화 이슈 해결 방안**

- Mutual exclusion(상호 배제) - 동시 접근 막음
- 스레드는 프로세스의 모든 데이터를 접근할 수 있으므로 여러 스레드가 변경하는 공유 변수에 대해 Exclusive Access가 필요하다. 또한 어느 한 스레드가 공유 변수를 갱신하는 동안 다른 스레드가 동시 접근하지 못하도록 막아야 햔다.

**Mutual esclusion(상호배제)**

- 임계 자원(ritical resource) - 동시에 수행하면 안 되는 자원
- 임계 영역(critical section) - CPU를 사용하고 있는 영역



**Mutext와 세마포어**

- Critical Section(임계 구역)에 대한 접근을 막기 위해 LOCKING 메커니즘이 필요하다.
  - **Mutex(binary semaphore)** - 임계 구역에 하나의 스레드만 들어갈 수 있다.
  - **Semaphore** - 임계구역에 여러 스레드가 들어갈 수 있고 **counter를 두어 동시에 리소스 접근할 수 있는 허용 가능한 스레드 수를 제어한다.** (임계구역에 하나의 스레드만 들어가게 되면 성능상 이슈가 발생할 수 있기 때문에 세마포어가 등장)



**세마포어**

- P : 검사(임계영역에 들어갈 때 체크하는 로직)
  - S값이 1 이상이면 임계 영역 진입 후 S값이 1차감한다.(S값이 0이면 대기한다.)
- V : 증가(임계영역에서 나올 때 처리하는 로직)
  - S값이 1을 더하고 임계영역을 나온다.
- S : 세마포어 값(동시에 임계영역에 들어갈 수 있는 스레드 수를 정의/ 초기 값 만큼 여러 프로세스가 동시 임계 영역 접근 가능하다.)

Ex. 만약 S가 2로 세팅한 상태에서 스레드 하나가 들어오면 S를 하나 차감 후 임계영역에 들어가게 되고 또 다른 스레드가 들어오면 또 다시 S를 하나 차감 후 임계영역에 들어갈 것이다. 그리고 다음 스레드가 들어오면 S는 현재 0이 되기 때문에 해당 스레드는 대기상태가 되는 것이다. 그러다 만약 임계영역에 있는 스레드 하나가 사용 끝날 시 V(S)에 의해 S는 증가가 되고 새로운 스레드가 임계영역을 들어가게 되는 것이다.

~~~
//해당 로직이 끝나면 바로 임계영역
P(S): wait(S) {
								while S <= 0	//대기
								;
      	S--;	//다른 프로세스 접근 제한
			}

//임계영역에 있는 스레드 하나가 끝날 시 해당 로직을 진행
V(S): signal(S) {
			S++;	//다른 프로세스 접근 허용
}
~~~



**세마포어 - 바쁜 대기**

- wait() 는 S가 0이 될 시점에 바로 임계영역에 들어가기 위해 반복문을 수행한다.
  - 즉, 바쁜 대기를 하는 것이다. busy waiting

~~~
//해당 로직이 끝나면 바로 임계영역
P(S): wait(S) {
								while S <= 0	//대기
								;
      	S--;	//다른 프로세스 접근 제한
}
~~~



**세마포어 - 대기 큐**

> 바쁜 대기의 성능 저하(반복문 수행에 따른)를 해결하기 위함이다.

- S가 음수일 경우, 바쁜 대기 대신 대기 큐에 넣는다.

count가 0이면 loop를 돌리면서 기다리는게 아니라 queue에 넣어 놓고 block을 시키는 것이다.

~~~
 //해당 로직이 끝나면 바로 임계영역
wait(S) {
			S->count--;
		if(S->count <= 0) {
			add this process to S->queue;
			block()
		}	
}
~~~

S를 증가시켰는데 count가 1보다 크면 queue에서 특정 프로세스를 제거하고 제거한 프로세스를 깨우면 되는 것이다.

~~~
signal(S) {
			S -> count++;
		if(S -> count > 1)
    	remove a process P from S->queue;
    	wakeup(P)
}
~~~



**주요 세마포어 함수**

- sem_open() : 세마포어를 생성한다.
- sem_wait() : 임계영역 접근 전, 세마포어를 잠그는 것이고 세마포어가 잠겨있다면 풀릴 때까지 대기한다.
- sem_post() : 공유자원에 대한 접근이 끝났을 때 세마포어를 잠금 해제하는 것이다.



